<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frosted Glass Effect with Shader</title>
    <style>
        body {
            margin: 0;
        }
        
        canvas {
            display: block;
        }
    </style>
</head>

<body>

    <script src="https://threejs.org/build/three.js"></script>



    <script>
        let scene, camera, renderer, cube, sphere, light;
        let isDragging = false;
        let lastMouseX = null,
            lastMouseY = null;
        let theta = Math.PI * 2;
        let phi = Math.PI / 2;


        const spheres = [];
        const MAX_ATTEMPTS = 10;

        // Variables para la rotación con el mouse



        const radius = 200; // Distancia de la cámara al centro



        document.addEventListener('mousedown', function(e) {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        document.addEventListener('mousemove', function(e) {
            if (!isDragging) return;

            let deltaX = e.clientX - lastMouseX;
            let deltaY = e.clientY - lastMouseY;

            theta -= deltaX * 0.01;
            phi -= deltaY * 0.01;

            // Clamp the vertical movement to prevent flipping
            phi = Math.max(0.01, Math.min(Math.PI - 0.01, phi));

            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });

        document.addEventListener('mouseup', function() {
            isDragging = false;
        });
        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xeeefff); // Fondo lila pizarra
            const amlight = new THREE.AmbientLight(0xffaaff); // soft white light
            scene.add(amlight);
            camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100;
            camera.lookAt(scene.position);
            renderer = new THREE.WebGLRenderer({
                antialias: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Cube rojo dentro de la esfera
            const cubeGeometry = new THREE.SphereGeometry(25, 64, 64);
            const cubeMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                specularIntensity: 10,
                emissive: 0xccccdd,


            });
            cubeMaterial.onBeforeCompile = function(shader) {
                const customTransformCode = `
                    float time = 5.0;
                    float a = .1;
                    float s = .4;
                    float n1 = a * 0.2 * sin(s*0.5 * position.x + time);
                    float n2 = a * 0.1 * sin(s*0.3 * position.y + time + 3.14/2.0);
                    float n3 =a * 0.15 * sin(s*0.7 * position.x + 0.5 * position.y - 1.2 * time);
                    float total = n1 + n2 + n3;
                    transformed += normal * total * 20.;
                `;

                shader.vertexShader = shader.vertexShader.replace(
                    '#include <begin_vertex>',
                    '\n#include <begin_vertex>' + customTransformCode
                );
            }

            cube = new THREE.Mesh(cubeGeometry, cubeMaterial);

            scene.add(cube);

            // Esfera con shader de frosted glass
            const sphereGeometry = new THREE.SphereGeometry(30, 64, 64);
            // Create PMREM Generator for environment map
            const pmremGenerator = new THREE.PMREMGenerator(renderer);
            pmremGenerator.compileEquirectangularShader();

            // Load environment map
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load('https://t3.ftcdn.net/jpg/02/96/91/52/360_F_296915204_6WqeZVClsMSz3Puc6WzfmxCDazJquKyr.jpg', (texture) => {
                const envMap = pmremGenerator.fromEquirectangular(texture).texture;
                // scene.background = envMap;
                physicalMaterial.envMap = envMap;
                physicalMaterial.needsUpdate = true;
                pmremGenerator.dispose();
            });
            const physicalMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xffeeff,
                metalness: 0.1,
                roughness: 0.4,
                clearcoat: 1,
                clearcoatRoughness: 1,
                transmission: 1,
                reflectivity: 1,
                transparent: true,
                opacity: 1.,
                thickness: 8.,
                ior: 1.2,
                iridiscense: 10.5,
                sheen: 2,
                sheenRoughness: 1.5,
                sheencColor: 0xffffff,
                envMap: textureLoader,
                envMapIntensity: 2,
                specularIntensity: .0

            });



            physicalMaterial.onBeforeCompile = function(shader) {
                const customTransformCode = `
                    float time = 5.0;
                    float a = .1;
                    float s = .4;
                    float n1 = a * 0.2 * sin(s*0.5 * position.x + time);
                    float n2 = a * 0.1 * sin(s*0.3 * position.y + time + 3.14/2.0);
                    float n3 =a * 0.15 * sin(s*0.7 * position.x + 0.5 * position.y - 1.2 * time);
                    float total = n1 + n2 + n3;
                    transformed += normal * total * 20.;
                `;

                shader.vertexShader = shader.vertexShader.replace(
                    '#include <begin_vertex>',
                    '\n#include <begin_vertex>' + customTransformCode
                );

                // Inyectamos el Fresnel en el fragmentShader
                shader.fragmentShader = `
                // varying vec3 vViewPosition;
                // varying vec3 vNormal;
                ${shader.fragmentShader}
                `;

                shader.fragmentShader = shader.fragmentShader.replace(
                    '#include <dithering_fragment>',
                    `
                    vec3 viewDirection = normalize(vViewPosition);

                    // Ajusta el factor de intensidad del efecto
                    float fresnelBias = 1.;

                    // Controla cómo se "extiende" el efecto Fresnel
                    float fresnelExponent = 2.0;

                    // Escala el efecto Fresnel
                    float fresnelScale = 2.0;

                    float fresnelEffect = fresnelScale * pow(clamp(fresnelBias - dot(normalize(vNormal), viewDirection), 0.0, 1.0), fresnelExponent);

                    // Ajusta los valores RGB para obtener diferentes tintes de color
                    vec3 fresnelColorTint = vec3(0.25, 0.25, 0.25);

                    // Define el color central o base
                    vec3 centerColor = vec3(.7, .8, 0.9); // Blanco como ejemplo

                    // Calcula el color final con el efecto Fresnel
                    vec3 finalColor = centerColor + fresnelColorTint * fresnelEffect;

                    // Controla qué tan fuerte es la mezcla
                    float mixingRatio = 0.6;

                    gl_FragColor.rgb = mix(gl_FragColor.rgb, finalColor, mixingRatio);
                    #include <dithering_fragment>
                    `
                );
            };

            sphere = new THREE.Mesh(sphereGeometry, physicalMaterial);

            sphere = new THREE.Mesh(sphereGeometry, physicalMaterial);
            scene.add(sphere);

            // Luz direccional
            light = new THREE.DirectionalLight(0xffffff, 0.5);
            light.castShadow = false;
            light.position.set(2, 2, 2);
            scene.add(light);
            light2 = new THREE.DirectionalLight(0xffccff, 0.);
            light2.position.set(-9, 10, 2);
            scene.add(light2);


            camera.position.z = 100;



            //

            // Esfera grande en el centro


            // Generar esferas pequeñas alrededor
            for (let i = 0; i < 10; i++) {
                const radius = Math.random() * (8 - 5) + 5;
                const smallGeometry = new THREE.SphereGeometry(radius, 64, 64);
                const smallMaterial = new THREE.MeshBasicMaterial({
                    color: Math.random() * 0xffffff,
                });
                const smallSphere = new THREE.Mesh(smallGeometry, physicalMaterial);
                const SmallCubeGeometry = new THREE.IcosahedronGeometry(radius * 0.5, 0);

                smallcube = new THREE.Mesh(SmallCubeGeometry, smallMaterial);
                let attempts = 0;
                do {
                    attempts++;
                    let phi = Math.random() * 2 * Math.PI;
                    let theta = Math.random() * Math.PI;

                    smallSphere.position.x = smallcube.position.x = (30 + radius) * Math.sin(theta) * Math.cos(phi);
                    smallSphere.position.y = smallcube.position.y = (30 + radius) * Math.sin(theta) * Math.sin(phi);
                    smallSphere.position.z = smallcube.position.z = (30 + radius) * Math.cos(theta);
                } while (isOverlap(smallSphere) && attempts < MAX_ATTEMPTS);

                if (attempts < MAX_ATTEMPTS) {
                    scene.add(smallSphere);
                    scene.add(smallcube);
                    spheres.push(smallSphere);
                }
            }

            light2 = new THREE.DirectionalLight(0xaaeeff, 0.);
            light2.position.set(-100, -100, -100);
            scene.add(light2);
        }

        function isOverlap(sphere) {
            for (let i = 0; i < spheres.length; i++) {
                const dist = sphere.position.distanceTo(spheres[i].position);
                if (dist < (sphere.geometry.parameters.radius + spheres[i].geometry.parameters.radius)) {
                    return true;
                }
            }
            return false;
        }

        function animate() {
            if (isDragging) {
                let radius = 100;

                camera.position.x = radius * Math.sin(phi) * Math.sin(theta);
                camera.position.y = radius * Math.cos(phi);
                camera.position.z = radius * Math.sin(phi) * Math.cos(theta);
                camera.lookAt(scene.position);
            }

            // cube.rotation.x += 0.01;
            // cube.rotation.y += 0.01;
            // cube.position.x += Math.cos(cube.rotation.x) / 4;
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }
    </script>

</body>

</html>